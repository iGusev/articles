>Approaches to modeling
https://gist.github.com/mindplay-dk/aaa4f4b747d09729c84a

В этой короткой статье я постараюсь кратко суммировать виды моделей, реализации которых я наблюдал на протяжении многих лет, отмечу некоторые преимущества и недостатки каждого подхода и подведу итог - что предпочитаю именно я и почему.

## Голые модели

Голые модели без каких-либо аннотаций, например:

```php
class User
{
    /** @var string */
    public $email;
}
```

Контроллеры и представления обычно полностью захардкожены с учетом конкретных типов входящих данных - это самый простой подход, но не самый изящный.

## Голые модели плюс объекты-типы

Каждая модель имеет свой объект, отвечающий за конкретный тип, обычно они совпадают с именованием свойств модели и содержат мета-информацию:

```php
class User
{
    /** @var string */
    public $email;
}

class UserType
{
    /** @var EmailInput */
    public $email;
    
    public function __construct()
    {
        $this->email = new EmailInput('email');
        $this->email->required = true;
        $this->email->unique = true;
    }
}
```

Это требует более четкой работы модели, но дает возможность повторного использования кода объектов-типов, например `$qunique` может быть использована для валидации CSRF-токенов, формирования схем, уникального ID и т.д.

Подход по-прежнему простой, т.к. не требует никаких фреймворков и библиотек.

## Аннотированные модели

Мета-данные внедрены внутрь исходного кода в виде аннотаций:

```php
class User
{
    /**
     * @var string
     * @input(type="text")
     */
    public $first_name;
}
```

Такой подход лежит на поверхности, он проще, чем подход моделирования через объекты-типы. Однако, парсинг аннотаций требует сложной работы с логикой, которая выполняет синтаксический анализ, валидацию, кэширование и др. На самом деле это далеко не так просто.

## 4. Meta-modeling with model code-generation

This involves building a run-time meta-model driving a code-generation framework, and could look something like this:

```php
$class = new MetaClass('User');
$class->addProperty(new EmailProperty('email'));

$code_generator->run($class);
```

The code generator would emit a model, a meta-model, and possibly other things like factory-classes etc.

Assuming passive (design-time) code-generation, as opposed to active (run-time) code-generation, this does provide static coupling at design-time, but perhaps not to the full extend - for example, refactorings (such as changing a property name) would involve a code-generation step, so even though you have static coupling, you can't really have automated refactorings.

It goes without saying, this approach is by no means simple - it involves building a large complicated code-generation engine, a lot of careful design, optimizations, etc.

## 5. Meta-modeling from a specification

This is the approach used by e.g. the [M# Language](http://www.msharp.co.uk/), in which a declarative specification is written in a custom language, consumed by a parser and used to drive a code-generator.

The premise of this is brevity, but obviously this comes at the cost of very high complexity, since a custom language requires custom IDE support, as well as all of the complexity and drawbacks of other code-generation approaches.

## 6. Code-generation from type-objects

Similar to approach number 2 ("Bare Models plus type-objects") but with the actual model being generated by letting a code-generator consume the type-object, just like any other service.

In some ways, this approach is both the best and the worst of all worlds - you get to describe and compose the model by implementing your type-objects using all the features of the host language, you avoid having to repeat anything, but it comes with the same problems (e.g. refactoring of the generated model) and at least
some of the complexity of the other code-generation systems.

# Conclusion

My favorite is number 2: Bare Models plus type-objects, because:

1. Avoids code-generation.
2. Static coupling and automated refactoring everywhere.
3. The non-static property-name as a string is encapsulated once in the type-object and never needs to be repeated in an unsafe manner.

The bare models plus type objects approach keeps the overall complexity low, keeps transparency high, avoids introduction of design-time steps
and completely obviates the need for any framework at the model-level - your models, and type-objects, are just code.

Granted, developers will need to learn and understand why every model is implemented as two classes, but this is a small price to pay - and it inspires learning and independent thinking.