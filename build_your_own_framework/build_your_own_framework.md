>Build your own PHP Framework with Symfony Components
http://www.sitepoint.com/build-php-framework-symfony-components/


Наверняка вы встречали Symfony в своей PHP-карьере, или по крайней мере слышали о нем. Но то, что вы можете не знать о Symfony, это то, что он состоит из отдельных библиотек, называемых _компоненты_, которые можно повторно использовать в любом PHP-приложении.

Например, популярный PHP фреймворк [Laravel](http://laravel.com/) был разработан с использованием нескольких Symfony компонентов, о которых и пойдет речь в этой статье. Очередная версия популярной CMS Drupal также строится на некоторых основных компонентах Symfony.

В этом уроке мы узнаем как построить PHP фреймворк с помощью этих компонентов, посмотрим как они могут взаимодействовать для создания базовой структуры любого веб-приложения.

![](http://habrastorage.org/files/32e/3bd/48d/32e3bd48d1194cdd9ee4bbc7461df419.jpg)

**Примечание:** Этот урок не охватывает _все_ Symfony компоненты и _все_ функции каждого из них. Посмотрим только на основные моменты, которые необходимы для создание минимально функциональной основы. Если вы хотите копнуть глубже, я рекомендую вам почитать отличную [документацию Symfony](http://symfony.com/doc/current/components/index.html).

<habracut/>

## Создание проекта

Начнем с нуля, с простого `index.php` файла в корневом каталоге нашего проекта и с использования [Composer](https://getcomposer.org/doc/00-intro.md) для установки зависимостей.

Теперь, напишем простой кусок кода:

```php
switch($_SERVER['PATH_INFO']) {
    case '/':
        echo 'This is the home page';
        break;
    case '/about':
        echo 'This is the about page';
        break;   
    default:
        echo 'Not found!';
}
```

Это очерь примитивный маршрутизатор, который просто смотрит адрес запрошенного URL-адреса (содержится в `$_SERVER['PATH_INFO']`) и выводит нужное `echo`.

## Компонент `HttpFoundation`

[`HttpFoundation`](http://symfony.com/doc/current/components/http_foundation/introduction.html) выступает в качестве слоя верхнего уровня для работы с http-потоком. Его наиболее важными точками входа являются два класса `Request` и `Response`.

`Request` позволяет нам иметь дело с информацией из http-запроса, такой как запрашиваемый URI или клиентские заголовки, он также абстрагирует стандартные глобальные переменные PHP (`$_GET`, `$_POST`, etc.). `Response` используется для отправки ответа обратно клиенту, вместо стандартных `header` или `echo` из "классического" PHP.

Установим его через Composer:

```bash
php composer.phar require symfony/http-foundation 2.5.*
```

Это положит библиотеку в каталог `/vendor`. Давайте модифицируем наш код с учетом новых возможностей:

```php
// Initializes the autoloader generated by composer
$loader = require 'vendor/autoload.php';
$loader->register();
 
use Symfony\Component\HttpFoundation\Request;
 
$request = Request::createFromGlobals();
 
switch($request->getPathInfo()) {
    case '/':
        echo 'This is the home page';
        break;
    case '/about':
        echo 'This is the about page';
        break;   
    default:
        echo 'Not found!';
}
```

Мы сделали довольно простые изменения:

* Создали объект класса `Request` через статический метод `createFromGlobals`. Вместо создания пустого объекта этот метод заполяет `Request` информацией из текущего запроса.
* Берем значение, возвращенное методом `getPathInfo`.

Заменим используемые `echo` на `Response` объект и отправим ответ клиенту через метод `send`, который выводит заголовки ответа и контент.


```php
$loader = require 'vendor/autoload.php';
$loader->register();
 
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
 
$request = Request::createFromGlobals();
$response = new Response();
 
switch ($request->getPathInfo()) {
case '/':
    $response->setContent('This is the website home');
    break;
 
    case '/about':
        $response->setContent('This is the about page');
        break;
 
    default:
        $response->setContent('Not found !');
    $response->setStatusCode(Response::HTTP_NOT_FOUND);
}
 
$response->send();
```

## Используем `HttpKernel` для обертки ядра фреймворка

```bash
php composer.phar require symfony/http-kernel 2.5.*
```

Сейчас, в самом простом случае, логика фреймворка расположена в нашем front-контроллере _index.php_. Если мы хотим добавить больше кода, то было бы лучше обернуть его в другой класс, который и стал бы "ядром" фреймворка.

Компонент [`HttpKernel`](http://symfony.com/doc/current/components/http_kernel/index.html) был задуман именно с этой целью. Он работает с `HttpFoundation`, преобразуя запрос в ответ и обесплечивает нас несколькими классами для достижения результата. На данный момент мы пока используем только `HttpKernelInterface` и определяемый им метод: `handle`.

Этот метод принимает в качестве аргумента `Request` и возвращает `Response`. Каждый класс реализующий этот интерфейс способен обработать запрос и вернуть соответстующий `Response` объект.

Давайте создадим класс `Core` в нашем фреймворке имплементирующий `HttpKernelInterface`. Положим файл `Core.php` в директорию `lib/Framework`:

```php
namespace Framework;
 
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\HttpKernelInterface;
 
class Core implements HttpKernelInterface
{
    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        switch ($request->getPathInfo()) {
            case '/':
                $response = new Response('This is the website home');
                break;
 
            case '/about':
                $response = new Response('This is the about page');
                break;
 
            default:
                $response = new Response('Not found !', Response::HTTP_NOT_FOUND);
        }
 
        return $response;
    }
}
```

**Примечание:** В методе `handle` есть два необязательных аргумента: Тип запроса и булево значение, указывающее, должно ли ядро выбрасывать исключение в случае возникновения ошибки. Мы не будем использовать их в этом уроке, но нужно реализовать метод с входными параметрами как в интерфейсе `HttpKernelInterface`, в ином случае PHP выдаст ошибку.

Единственное, что мы сделали тут - это переместили существующий код в метод `handle`. Теперь избавимся от него в `index.php` и заменим на только что созданный класс:

```php
require 'lib/Framework/Core.php';
 
$request = Request::createFromGlobals();
 
// Our framework is now handling itself the request
$app = new Framework\Core();
 
$response = $app->handle($request);
$response->send();
```

## Улучшаем систему роутинга

Есть проблема с нашим классом: он содержит логику маршрутизации нашего приложения. Если мы захотим добавить еще несколько URL-адресов, то придется модифицировать код внутри фреймворка, что явно не слишком хорошая идея. Кроме того, это означает добавление блока `case` для каждого нового маршрута. Нет, мы определенно не хотим скатываться до такого.

Решение заключается в добавлении системы маршрутизации в наш фреймворк. Мы можем сделать это через метод `map`, который будет связывать URI и вызов соответствующего кода для выполнения:


```php
class Core implements HttpKernelInterface
{
    protected $routes = array();
 
    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        $path = $request->getPathInfo();
         
        // Does this URL match a route?
        if (array_key_exists($path, $this->routes)) {
            // execute the callback
            $controller = $routes[$path];
            $response = $controller();
        } else {
            // no route matched, this is a not found.
            $response = new Response('Not found!', Response::HTTP_NOT_FOUND);
        }
 
        return $response;
    }
     
    // Associates an URL with a callback function
    public function map($path, $controller) {
        $this->routes[$path] = $controller;
    }
}
```

Теперь маршруты могут быть установлены непосредственно в фронт-контроллере:

```php
$app->map('/', function () {
    return new Response('This is the home page');
});
 
$app->map('/about', function () {
    return new Response('This is the about page');
});
 
$response = $app->handle($request);
```

Такая крошечная система маршрутизации работает хорошо, но имеет серьезные недостатки: а что если мы захотим понимать динамические URL-адреса, содержащие параметры? Например URL `posts/:id`, где `id` - переменная, по которой находится необходимый пост в базе данных

Нам нужна более гибкая и мощная система, поэтому мы будем использовать еще один Symfony-компонент - [Routing](http://symfony.com/doc/current/book/routing.html).

```bash
php composer.phar require symfony/routing 2.5.*
```

Использование компонента маршрутизации позволяет нам загрузить объекты `Route` в `UrlMatcher`, что и будет являться картой запрошенных URI и соответствующих маршрутов. Объект `Route` может содержать любые атрибуты, которые могут помочь нам выполнить правильную часть приложения. В нашем случае, такой объект будет содержать коллбэк для выполнения, в случае если маршрут совпадает. Кроме того, все динамические параметры, содержащиеся в URL-адресе также будут присутствовать в объекте в виде атрибутов.

Для того чтобы реализовать все это, мы должны сделать следующие изменения:

* Заменить массив `routes`, содержащий наши маршруты, на экземпляр `RouteCollection`
* Изменить метод `map` для регистрации маршрутов из этой коллекции
* Создать экземпляр `UrlMatcher` и сообщить ему какие маршруты совпадают с запрошенными URI с помощью `RequestContext`


```php
use Symfony\Component\Routing\Matcher\UrlMatcher;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
use
Symfony\Component\Routing\Exception\ResourceNotFoundException;
 
class Core implements HttpKernelInterface
{
    /** @var RouteCollection */
    protected $routes;
 
    public function __construct()
    {
        $this->routes = new RouteCollection();
    }
 
    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        // create a context using the current request
        $context = new RequestContext();
        $context->fromRequest($request);
         
        $matcher = new UrlMatcher($this->routes, $context);
 
        try {
            $attributes = $matcher->match($request->getPathInfo());
            $controller = $attributes['controller'];
            $response = $controller();
        } catch (ResourceNotFoundException $e) {
            $response = new Response('Not found!', Response::HTTP_NOT_FOUND);
        }
 
        return $response;
    }
 
    public function map($path, $controller) {
        $this->routes->add($path, new Route(
            $path,
            array('controller' => $controller)
        ));
    }
}
```

Метод `match` будет сопостовлять известные паттерны маршрутов и возвращать соответствующие атрибуты в случае успеха. В обратной ситуации он выбросит `ResourceNotFoundException`, который мы отловим для отображения 404 страницы.


We can now take advantage of the Routing component to retrieve any URL parameters. After getting rid of the `controller` attribute, we can call our callback function by passing other parameters as arguments (using the `call_user_func_array` function):

```php
try {
        $attributes = $matcher->match($request->getPathInfo());
        $controller = $attributes['controller'];
        unset($attributes['controller']);
        $response = call_user_func_array($controller, $attributes);
    } catch (ResourceNotFoundException $e) {
        $response = new Response('Not found!', Response::HTTP_NOT_FOUND);
    }
 
    return $response;
}
```

We can now easily handle dynamic URLs like this:

```php
$app->map('/hello/{name}', function ($name) {
    return new Response('Hello '.$name);
});
```

Note that this is very similar to what the Symfony full-stack framework is doing: we inject URL parameters into the right controller.

## Hooking into the framework

The Symfony framework also provides various way to hook into the request lifecycle and to change it. A good example is the security layer intercepting a request which attempts to load an URL between a firewall.

All of this is possible thanks to the [EventDispatcher](http://symfony.com/doc/current/components/event_dispatcher/introduction.html) component, which allows different components of an application to communicate implementing the [Observer](http://en.wikipedia.org/wiki/Observer_pattern) pattern.

```bash
php composer.phar require symfony/event-dispatcher 2.5
```

At the core of it, there is the EventDispatcher class, which registers listeners of a particular event. When the dispatcher is notified of an event, all known listeners of this event are called. A listener can be any valid PHP callable function or method.

We can implement this in our framework by adding a property `dispatcher` that will hold an `EventDispatcher` instance, and an `on` method, to bind an event to a PHP callback. We’ll use the dispatcher to register the callback, and to fire the event later in the framework.

```php
use Symfony\Component\Routing\Matcher\UrlMatcher;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\EventDispatcher\EventDispatcher
 
class Core implements HttpKernelInterface
{
    /** @var RouteCollection */
    protected $routes;
 
    public function __construct()
    {
        $this->routes = new RouteCollection();
        $this->dispatcher = new EventDispatcher();
    }
     
    // ... 
 
    public function on($event, $callback)
    {
        $this->dispatcher->addListener($event, $callback);
    }
}
```

We are now able to register listeners, which are just simple PHP callbacks. Let’s write now a `fire` method which will tell our dispatcher to notify all the listeners he knows when some event occurs.

```php
public function fire($event)
{
    return $this->dispatcher->dispatch($event);
}
```

In less than ten lines of code, we just added a nice event listener system to our framework, thanks to the EventDispatcher component.

The `dispatch` method also takes a second argument, which is the dispatched event object. Every event inherits from the generic `Event` class, and is used to hold any information related to it.

Let’s write a `RequestEvent` class, which will be immediately fired when a request is handled by the framework. Of course, this event must have access to the current request, using an attribute holding a `Request` instance.

```php
namespace Framework\Event;
 
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\EventDispatcher\Event;
 
class RequestEvent extends Event
{
    protected $request;
 
    public function setRequest(Request $request)
    {
        $this->request = $request;
    }
 
    public function getRequest()
    {
        return $this->request;
    }
}
```

We can now update the code in the `handle` method to fire a `RequestEvent` event to the dispatcher every time a request is received.

```php
public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
        {
            $event = new RequestEvent();
            $event->setRequest($request);
 
            $this->dispatcher->dispatch('request', $event);
            // ...
        }
```

This way, all called listeners will be able to access the `RequestEvent` object and also the current `Request`. For the moment, we wrote no such listener, but we could easily imagine one that would check if the requested URL has restricted access, before anything else happens.

```php
$app->on('request', function (RequestEvent $event) {
    // let's assume a proper check here
    if ('admin' == $event->getRequest()->getPathInfo()) {
        echo 'Access Denied!';
        exit;
    }
});
```

This is a very basic security system, but you could imagine implementing anything you want, because we now have the ability to hook into the framework at any moment, which makes it much more scalable.

## Заключение

Читая этот урок, вы увидели, что Symfony-компоненты являются не только отличными автономными библиотеками, но и могут взаимодействовать для построения фреймворка именно под ваши нужды. Есть еще много действительно интересных компонентов, таких как [`DependencyInjection`](http://symfony.com/doc/current/components/dependency_injection/introduction.html) или [`Security`](http://symfony.com/doc/current/components/security/introduction.html)

И конечно же, такие гиганты как Symfony или Laravel отточили свои компоненты до предела, дав мощные инструменты для решения наших задач.

P.S. Как вы думаете, ушло ли время велосипедостроения? Делают ли сейчас разработчики свои фреймворки полностью с нуля? Есть ли тренд?