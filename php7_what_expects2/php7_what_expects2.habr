<blockquote>Это вторая часть нашей минисерии статей "Чего ждать от PHP7". <a href="http://habrahabr.ru/post/257237/">Читать часть 1</a>.
</blockquote>
Как вы наверное уже знаете, PHP7 придет в этом году! И сейчас амое время узнать что же нового он нам принесет.

В <a href="http://habrahabr.ru/post/257237/" title="Чего ждать, когда ждешь ребенка: PHP 7, часть 1">первой части данной серии</a> мы рассмотрели некоторые наиболее важные изменения в PHP7 и две крупные новые возможности. В этой статье рассмотрим еще шесть, о которых вы точно захотите узнать.

<h4>Новый экранирующий символ для Unicode</h4>
Добавление нового escape-символа <code>\u</code> позволяет нам указываеть специфические unicode символы внутри PHP-строк <i>(да-да, те самые emoji и не только)</i>.

Синтаксис выглядит так - <code>\u{CODEPOINT}</code>, например, зеленое сердце, <img src="//habrastorage.org/files/e1e/068/0ee/e1e0680eeb57459bba3bcc05585f51d9.png"/>, может быть выражено как PHP-строка: <code>"\u{1F49A}"</code>.
<habracut/>
<h4>Оператор объединения со значеним NULL (<a href="https://wiki.php.net/rfc/isset_ternary">Null Coalesce Operator</a>)</h4>
Еще один новый оператор - <code>??</code>. Он возвращает левый операнд, если он не имеет значение NULL; в противном случае возвращается правый операнд.

Самое главное, что не генерирует <code>notice</code>, если левый операнд является несуществующей переменной. В отличии от короткого тернарного оператора <code>?:</code>, он работает как <code>isset()</code>.

Вы также можете использовать цепочки операторов, чтобы вернуть первый ненулевой из данного набора:

<source lang="php">
$config = $config ?? $this->config ?? static::$defaultConfig;
</source>
<h4>Привязка замыканий во время вызова</h4>
С PHP5.4 к нам пришли нововведения <code>Closure->bindTo()</code> и <code>Closure::bind()</code>, которые позволяют изменить привязку <code>$this</code> и области вызова, вместе, или по отдельности, создавая дубликат замыкания.

PHP7 теперь добавляет легкий способ сделать это прямо во время вызова, связывая <code>$this</code> и область вызова с помощью <code>Closure->call()</code>. Этот метод принимает объект в качестве своего первого аргумента, а затем любые другие аргументы, которые пойдут в замыкание:

<source lang="php">
class HelloWorld {
     private $greeting = "Hello";
}

$closure = function($whom) { echo $this->greeting . ' ' . $whom; }

$obj = new HelloWorld();
$closure->call($obj, 'World'); // Hello World
</source>
<h4>Группировка деклараций <code>use</code></h4>
Если вам когда-либо приходилось импортировать много классов из одного и того же пространства имен, вы, наверное, были очень счастливы, когда IDE делала всю основную работу за вас. Для всех остальных, и для краткости, в PHP7 теперь есть возможность <a href="https://wiki.php.net/rfc/group_use_declarations">группировать декларирование операторов <code>use</code></a>. Это позволит быстрее и удобнее работать с большим количеством импортов и сделает код читаемее:

<source lang="php">
// Original
use Framework\Component\SubComponent\ClassA;
use Framework\Component\SubComponent\ClassB as ClassC;
use Framework\Component\OtherComponent\ClassD;
</source>
<source lang="php">
// With Group Use
use Framework\Component\{
     SubComponent\ClassA,
     SubComponent\ClassB as ClassC,
     OtherComponent\ClassD
};
</source>
Группировка может использоваться с константами и импортируемыми функциями, вы можете смешивать все вместе:

<source lang="php">
use Framework\Component\{
     SubComponent\ClassA,
     function OtherComponent\someFunction,
     const OtherComponent\SOME_CONSTANT
};
</source>
<h4>Улучшение генераторов</h4>
<h5><code>return</code> в генераторах</h5>
В генераторах появились две очень интересные возможности. Первая - <a href="https://wiki.php.net/rfc/generator-return-expressions">Generator Return Expressions</a>, позволяющая возвращать значение после (успешного) завершения работы генератора.

До PHP7, если вы пытались что-нибудь вернуть в генераторе, это приводило к ошибке. Однако, теперь вы можете вызвать <code>$generator->getReturn()</code>, чтобы получить возвращаемое значение.

Если генератор еще не завершился или выбросил непойманное исключение, вызов <code>$generator->getReturn()</code> сгенерирует исключение.

Если же генератор завершен, но не объявлен <code>return</code>, то метод вернет <code>NULL</code>.

Пример:

<source lang="php">
function gen() {
    yield "Hello";
    yield " ";
    yield "World!";

    return "Goodbye Moon!";
}

$gen = gen();

foreach ($gen as $value) {
    echo $value; 
}

// Outputs "Hello" on iteration 1, " " on iterator 2, and "World!" on iteration 3

echo $gen->getReturn(); // Goodbye Moon!
</source>
<h5>Делегирование генератора</h5>
Вторая особенность является гораздо более захватывающей: <a href="https://wiki.php.net/rfc/generator-delegation">делегирование генератора</a>. Это позволяет вернуть другую итерабельную структуру - будь то массив, итератор или другой генератор.

Важно понимать, что итерации суб-структур осуществляются именно через самую внешнюю петлю, как если бы это была одна плоская структура, а не рекурсивный вызов.

Это утверждение также справедливо при отправке данных в генератор или выбросе исключений. Они передаются в суб-структуру, как если бы это был ее непосредственный вызов.

Синтаксис такой - <code>yield from &lt;expression&gt;</code>. Посмотрим на примере:

<source lang="php">
function hello() {
     yield "Hello";
     yield " ";
     yield "World!";

     yield from goodbye();
}

function goodbye() {
     yield "Goodbye";
     yield " ";
     yield "Moon!";
}

$gen = hello();
foreach ($gen as $value) {
     echo $value;
}
</source>
При каждой итерации будет выводиться:

<ol>
	<li>"Hello"</li>
	<li>" "</li>
	<li>"World!"</li>
	<li>"Goodbye"</li>
	<li>" "</li>
	<li>"Moon!"</li>
</ol>
Стоит упомянуть еще один ньюанс: поскольку суб-структуры привносят свои собственные ключи, вполне возможно, что один и тот же ключ будет возвращен за несколько итераций. Недопущение подобного - это ваша ответственность, конечно же, если для вас это важно.

<h4><code>\EngineException</code></h4>
Обработка фатальный и catchable фатальных ошибок в PHP традиционна была невозможна, или по крайней мере очень сложна. Но с добавлением <a href="https://wiki.php.net/rfc/engine_exceptions_for_php7">Engine исключений</a>, многие из этих ошибок будут теперь выбрасывать исключение вместо самой ошибки.

Теперь, когда фатальная или catchable фатальная неустранимая ошибка возникнут, выбросится исключение, позволяющее обработать ошибку корректно. Если его не трогать, то это приведет к традиционной фатальной ошибке необработанного исключения.

Эти исключения являются <code>\EngineException</code> объектами, и в отличии от всех пользовательских исключений, они не наследуются от базового класса <code>\Exception</code>. Это сделано специально, чтобы существующий код, который ловит класс <code>\Exception</code> не отлавливал и фатальные ошибки, изменяя свое поведение. Таким образом сохраняется обратная совместимость.

В будущем, если вы хотите поймать как традиционные исключения, так и engine исключения, вам нужно будет отлавливать их новый общий родительский класс <code>\BaseException</code>.

Кроме того, ошибки парсинга в выполняемом функцией <code>eval()</code> коде теперь будут выбрасывать <code>\ParseException</code>, а несоответствие типов приведет к <code>\TypeException</code>.

Пример:

<source lang="php">
try {
    nonExistentFunction();
} catch (\EngineException $e) {
     var_dump($e);
}

object(EngineException)#1 (7) {
  ["message":protected]=>
  string(32) "Call to undefined function nonExistantFunction()"
  ["string":"BaseException":private]=>
  string(0) ""
  ["code":protected]=>
  int(1)
  ["file":protected]=>
  string(17) "engine-exceptions.php"
  ["line":protected]=>
  int(1)
  ["trace":"BaseException":private]=>
  array(0) {
  }
  ["previous":"BaseException":private]=>
  NULL
}
</source>
<h4>Скоро!</h4>
РНР 7.0.0 исполнилось всего восемь месяцев, и, вполне возможно, это будет самым быстрым релизом мажорной версии в истории PHP. Пока все еще в альфа-версии, но уже сейчас все складывается очень хорошо.

И вы можете помочь сделать еще лучше.

<h5>Проверь свой код</h5>
Возьмите <a href="http://github.com/rlerdorf/php7dev">PHP7 vagrant box</a> от Расмуса и запустите ваши тесты или проверьте по своему чек-листу ваше приложение. Сообщите о <a href="http://bugs.php.net">багах</a> в проект, повторяйте регулярно :)

<h5>Помоги GoPHP7-ext</h5>
Одним из основных препятствий для PHP7 является большое количество работы по обновлению всех расширений для работы с новым Zend Engine 3.

Если вы используете расширение, которое не слишком популярно и известно, и вам не нравится уровень его поддержки, или же у вас есть свои собственные расширения - посмотрите на <a href="http://gophp7.org/gophp7-ext/">проект GoPHP7-ext</a> и примите участие, перенеся свои расширения на новый движок.

<h5>Документация</h5>
Каждая новая фича PHP7 имеет свой RFC. Все они могут быть найдены в <a href="http://wiki.php.net/rfc">вики PHP.net</a> и являются хорошей отправной точкой для написания новой документации. Вы можете сделать это <a href="https://edit.php.net">онлайн в GUI среде</a>, в том числе и закоммитить (если у вас есть карма) или отправить патч на проверку.

<h4>Заключение</h4>
РНР 7 будет <i>великим</i>!

Протестируйте ваши приложения. Помогите перенести расширения.

P.S. вы уже пробовали PHP7? Как вы относитесь к нововведениям? Если что-то с чем несогласны? Когда вы планируете перейти на новую версию? Напишите свои мысли по этому поводу в комментариях.