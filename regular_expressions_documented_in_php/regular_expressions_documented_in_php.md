>Regular expressions documented in PHP
http://nyamsprod.com/blog/2015/regular-expressions-documented-in-php/

Документирование регулярных выражений в PHP

Одним из самых сложных аспектов использования регулярных выражений является оформление их документации. Чаще всего при наличии сложного регулярного выражения, даже будучи его создателем, спустя какое-то время и без должной документации забудете как оно устроено. Во время чтения [недавней статьи о регулярных выражениях](http://www.sitepoint.com/demystifying-regex-with-practical-examples/) я был удивлен, что в ней не фигурируют какие-либо советы о том как их документировать. Давайте заполним этот пробел.

Рассмотрим в качестве примера [регулярное выражение из RFC3986](http://tools.ietf.org/html/rfc3986#appendix-B), использующееся для анализа любого заданного URI и разбора его на части. Сперва адаптируем его для использования в PHP c помощью следующего кода:

```php
$uri = 'http://www.ics.uci.edu/pub/ietf/uri/#Related';
$regexp = ',^(([^:/?\#]+):)?(//([^/?\#]*))?([^?\#]*)(\?([^\#]*))?(\#(.*))?,';
preg_match($regexp, $uri, $matches);
var_dump($matches);

// array(10) {
//    [0]=> string(44) "http://www.ics.uci.edu/pub/ietf/uri/#Related"
//    [1]=> string(5) "http:"
//    [2]=> string(4) "http"
//    [3]=> string(17) "//www.ics.uci.edu"
//    [4]=> string(15) "www.ics.uci.edu"
//    [5]=> string(14) "/pub/ietf/uri/"
//    [6]=> string(0) ""
//    [7]=> string(0) ""
//    [8]=> string(8) "#Related"
//    [9]=> string(7) "Related"
// }
```

Выражение работает как и ожидалось, но если у вас нет очень хорошей памяти, вы никак не узнаете, что итоговый индекс представляет собой компоненты URI. Одним из способов преодоления этой проблемы является добавление комментариев перед регулярным выражением, где объясняется каждая из частей. Но после момента создания комментария у вас нет никакой гарантии, что кто-нибудь еще не переопределит их в будущем и забудет поправить документацию в коде. Нам необходимо более надежное решение.

Благодаря предусмотренным в PHP механизмам регулярных выражений, начиная с PHP5.2, вы можете [использовать именованные подмаски в ваших регулярных выражениях](http://be2.php.net/manual/en/regexp.reference.subpatterns.php). С помощью них мы улучшим читаемость нашего выражения, а также его результирующий массив:

```php
$uri = 'http://www.ics.uci.edu/pub/ietf/uri/#Related';
$regexp = ',^((?<scheme>[^:/?\#]+):)?(?<authority>//([^/?\#]*))?(?<path>[^?\#]*)(?<query>\?([^\#]*))?(?<fragment>\#(.*))?,';
preg_match($regexp, $uri, $matches);
var_dump($matches);
// array(15) { 
//     [0]=> string(44) "http://www.ics.uci.edu/pub/ietf/uri/#Related"
//     [1]=> string(5) "http:"
//     ["scheme"]=> string(4) "http"
//     [2]=> string(4) "http"
//     ["authority"]=> string(17) "//www.ics.uci.edu"
//     [3]=> string(17) "//www.ics.uci.edu"
//     [4]=> string(15) "www.ics.uci.edu"
//     ["path"]=> string(14) "/pub/ietf/uri/"
//     [5]=> string(14) "/pub/ietf/uri/"
//     ["query"]=> string(0) ""
//     [6]=> string(0) ""
//     [7]=> string(0) ""
//     ["fragment"]=> string(8) "#Related"
//     [8]=> string(8) "#Related"
//     [9]=> string(7) "Related"
// }
```

Теперь, наряду с наличием числовых индексов, следующих в том же порядке, что и в предыдущем примере, возвращаемый массив также включает именованные индексы для каждого выбранного шаблона. Присваивая осмысленные имена вашим именованным подмаскам, вы автоматически документируете ваши регулярные выражения. В нашем примере мы используем наименования частей URI пути для непосредственного обозначения разбирающих их шаблонов.

Согласно [официальной документации PHP](http://be2.php.net/manual/ru/regexp.reference.internal-options.php) мы можем использовать модификатор `х` в шаблоне для улучшения форматирования регулярного выражения.

> Если используется данный модификатор, неэкранированные пробелы, символы табуляции и пустой строки будут проигнорированы в шаблоне, если они не являются частью символьного класса. Также игнорируются все символы между неэкранированным символом '#' (если он не является частью символьного класса) и символом перевода строки (включая сами символы `\n` и `#`).

Другими словами, этот модификатор может использоваться для:
* Разбиение регулярного выражения на несколько строк.
* Добавление встроенных комментариев для дальнейшего документирования регулярного выражения.

Таким образом, с помощью именованных шаблонов и модификатора `x`, мы сможем сделать так:

```php
$uri = 'http://www.ics.uci.edu/pub/ietf/uri/#Related';
$regexp = ',^
        ((?<scheme>[^:/?\#]+):)?      # URI scheme component
        (?<authority>//([^/?\#]*))?   # URI authority part
        (?<path>[^?\#]*)              # URI path component
        (?<query>\?([^\#]*))?         # URI query component
        (?<fragment>\#(.*))?          # URI fragment component
        ,x';      
preg_match($regexp, $uri, $matches);
var_dump($matches);
// array(15) { 
//     [0]=> string(44) "http://www.ics.uci.edu/pub/ietf/uri/#Related"
//     [1]=> string(5) "http:"
//     ["scheme"]=> string(4) "http"
//     [2]=> string(4) "http"
//     ["authority"]=> string(17) "//www.ics.uci.edu"
//     [3]=> string(17) "//www.ics.uci.edu"
//     [4]=> string(15) "www.ics.uci.edu"
//     ["path"]=> string(14) "/pub/ietf/uri/"
//     [5]=> string(14) "/pub/ietf/uri/"
//     ["query"]=> string(0) ""
//     [6]=> string(0) ""
//     [7]=> string(0) ""
//     ["fragment"]=> string(8) "#Related"
//     [8]=> string(8) "#Related"
//     [9]=> string(7) "Related"
// }
```

As you can see without resorting to docblocks we have a relatively complex regular expression break down into simple parts and self documented. The matches are preserved and self documented to help developers understand the regular expression they wrote years ago.

Как вы можете видеть, не прибегая к doc-блоков мы имеем относительно сложное регулярное выражение можно разбить на простые части и самостоятельная документально. Матчи сохраняются и самостоятельная документально, чтобы помочь разработчикам понять регулярные выражения они писали лет назад.

Как вы можете видеть, относительно сложное регулярное выражение можно разбить на простые и самодокументируемые части не прибегая к doc-блокам. Сохранение числовых индексов также является большим плюсом при документировании уже существующих выражений, написанных годы назад.
